<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="annot"><span class="hs-comment">{-|
Copyright:
    Predictable Network Solutions Ltd., 2024
License: BSD-3-Clause
Maintainer: neil.davies@pnsol.com

This module brings data types and functions
for &#8710;Q System Development into scope.

Specifically,

    * type classes in &quot;DeltaQ.Class&quot;

        * 'Outcome' for outcomes and their combinations
        * 'DeltaQ' for probability distribution of completion times

    * type class instance in &quot;DeltaQ.PiecewisePolynomial&quot;

        * @'Durations' a@ for a probability distribution with numeric type @a@.
        This type represents a mixed discrete / continuous probability distribution
        where the continuous part is represented in terms of piecewise polynomials.
-}</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="DeltaQ.html"><span class="hs-identifier">DeltaQ</span></a></span><span>
</span><span id="line-24"></span><span>    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Example</span></span><span>
</span><span id="line-25"></span><span>      </span><span class="annot"><span class="hs-comment">-- $example</span></span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>      </span><span class="annot"><span class="hs-comment">-- * Modules</span></span><span>
</span><span id="line-28"></span><span>      </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="DeltaQ.Class.html"><span class="hs-identifier">DeltaQ.Class</span></a></span><span>
</span><span id="line-29"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="DeltaQ.PiecewisePolynomial.html"><span class="hs-identifier">DeltaQ.PiecewisePolynomial</span></a></span><span>
</span><span id="line-30"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="DeltaQ.Class.html"><span class="hs-identifier">DeltaQ.Class</span></a></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="DeltaQ.PiecewisePolynomial.html"><span class="hs-identifier">DeltaQ.PiecewisePolynomial</span></a></span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span class="annot"><span class="hs-comment">{-$example

In order to demonstrate the use of this module,
we explore a __real-world example__
which occurred during the design of the Cardano blockchain.

Problem: We want to design a __computer network__
through which we can send a __message__
from any computer A to any other computer Z.

However, instead of connecting each pair of computers through a direct
TCP/IP link, we want to save on connection cables
and only connect each computer to a fixed number of other computers;
these computers are called /neighbors/ and
this number is called the /node degree/ @d@ of our network.
A message from computer A to computer Z will
first be sent to one of the @d@ neighbors of A,
then be __relayed__ to one of the neighbor's neighbors,
and so on until it reaches Z.
hrough the network.

How much __time__ does it take to send the message
from computer A to computer Z through the network?
How should we choose the parameter @d@ in order to improve this time?
How can we refine the network design in other ways?

This questions can be answered by using this module.

@
import DeltaQ
@

We start with an __estimate__ based on __measured__ transfer times.
Depending on geographic distance and location,
a __direct TCP/IP connection__ may delive a message within
different amounts of time.
We distinguish between `short`, `medium` and `long` distance.
For sending a block of 64k bytes of data,
representative times are (in seconds)

&gt; short, medium, long :: Durations Rational
&gt; short  = wait 0.024 -- seconds
&gt; medium = wait 0.143 -- seconds
&gt; long   = wait 0.531 -- seconds

(These are delay times for the data to arrive,
not roundtrip times for the sending computer to receive
an acknowledgment.)

If we assume that a direct TCP/IP connection between computers has
an equal probability of being `short`, `medium`, or `long`,
the probability distribution of delay times for a __single hop__ is

&gt; hop :: Durations Rational
&gt; hop = choices [(1/3, short), (1/3, medium), (1/3, long)]

The distribution of delay times for a __sequence of hops__ is

&gt; hops :: Int -&gt; Durations Rational
&gt; hops 1 = hop
&gt; hops n = hop .&gt;&gt;. hops (n-1)

For example, the probability of five hops to succeed within 2 seconds
is

&gt; &gt; fromRational (successWithin (hops 5) 2) :: Double
&gt; 0.9547325102880658


-}</span></span></pre></body></html>