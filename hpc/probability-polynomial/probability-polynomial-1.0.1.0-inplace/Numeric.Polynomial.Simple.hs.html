<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">    2 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    3 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    4 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>{-|
<span class="lineno">    7 </span>Copyright   : Predictable Network Solutions Ltd., 2020-2024
<span class="lineno">    8 </span>License     : BSD-3-Clause
<span class="lineno">    9 </span>Description : Polynomials and computations with them.
<span class="lineno">   10 </span>-}
<span class="lineno">   11 </span>module Numeric.Polynomial.Simple
<span class="lineno">   12 </span>    ( -- * Basic operations
<span class="lineno">   13 </span>      Poly
<span class="lineno">   14 </span>    , eval
<span class="lineno">   15 </span>    , degree
<span class="lineno">   16 </span>    , constant
<span class="lineno">   17 </span>    , zero
<span class="lineno">   18 </span>    , monomial
<span class="lineno">   19 </span>    , fromCoefficients
<span class="lineno">   20 </span>    , toCoefficients
<span class="lineno">   21 </span>    , scale
<span class="lineno">   22 </span>    , scaleX
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>      -- * Advanced operations
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>      -- ** Convenience
<span class="lineno">   27 </span>    , display
<span class="lineno">   28 </span>    , lineFromTo
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>      -- ** Algebraic
<span class="lineno">   31 </span>    , translate
<span class="lineno">   32 </span>    , integrate
<span class="lineno">   33 </span>    , differentiate
<span class="lineno">   34 </span>    , euclidianDivision
<span class="lineno">   35 </span>    , convolve
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>      -- ** Numerical
<span class="lineno">   38 </span>    , compareToZero
<span class="lineno">   39 </span>    , countRoots
<span class="lineno">   40 </span>    , isMonotonicallyIncreasingOn
<span class="lineno">   41 </span>    , root
<span class="lineno">   42 </span>    , squareFreeFactorisation
<span class="lineno">   43 </span>    ) where
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>import Control.DeepSeq
<span class="lineno">   46 </span>    ( NFData
<span class="lineno">   47 </span>    , NFData1
<span class="lineno">   48 </span>    )
<span class="lineno">   49 </span>import GHC.Generics
<span class="lineno">   50 </span>    ( Generic
<span class="lineno">   51 </span>    , Generic1
<span class="lineno">   52 </span>    )
<span class="lineno">   53 </span>import Math.Combinatorics.Exact.Binomial -- needed to automatically derive NFData
<span class="lineno">   54 </span>    ( choose
<span class="lineno">   55 </span>    )
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import qualified Data.Function.Class as Fun
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>{-----------------------------------------------------------------------------
<span class="lineno">   60 </span>    Basic operations
<span class="lineno">   61 </span>------------------------------------------------------------------------------}
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>-- | Polynomial with coefficients in @a@.
<span class="lineno">   64 </span>newtype Poly a = Poly [a]
<span class="lineno">   65 </span>    -- INVARIANT: List of coefficients from lowest to highest degree.
<span class="lineno">   66 </span>    -- INVARIANT: The empty list is not allowed,
<span class="lineno">   67 </span>    -- the zero polynomial is represented as [0].
<span class="lineno">   68 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic1</span></span></span></span>)
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>instance <span class="decl"><span class="nottickedoff">NFData a =&gt; NFData (Poly a)</span></span>
<span class="lineno">   71 </span>instance <span class="decl"><span class="nottickedoff">NFData1 Poly</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>instance <span class="decl"><span class="istickedoff">(Eq a, Num a) =&gt; Eq (Poly a)</span></span> where
<span class="lineno">   74 </span>    <span class="decl"><span class="istickedoff">x == y =</span>
<span class="lineno">   75 </span><span class="spaces">        </span><span class="istickedoff">toCoefficients (trimPoly x) == toCoefficients (trimPoly y)</span></span>
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>{-| The constant polynomial.
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>&gt; eval (constant a) = const a
<span class="lineno">   80 </span>-}
<span class="lineno">   81 </span>constant :: a -&gt; Poly a
<span class="lineno">   82 </span><span class="decl"><span class="istickedoff">constant x = Poly [x]</span></span>
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>-- | The zero polynomial.
<span class="lineno">   85 </span>zero :: Num a =&gt; Poly a
<span class="lineno">   86 </span><span class="decl"><span class="istickedoff">zero = constant 0</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>{-| Degree of a polynomial.
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>The degree of a constant polynomial is @0@, but
<span class="lineno">   91 </span>the degree of the zero polynomial is @-1@ for Euclidean division.
<span class="lineno">   92 </span>-}
<span class="lineno">   93 </span>degree :: (Eq a, Num a) =&gt; Poly a -&gt; Int
<span class="lineno">   94 </span><span class="decl"><span class="istickedoff">degree x = case trimPoly x of</span>
<span class="lineno">   95 </span><span class="spaces">    </span><span class="istickedoff">Poly [0] -&gt; -1</span>
<span class="lineno">   96 </span><span class="spaces">    </span><span class="istickedoff">Poly xs -&gt; length xs - 1</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>-- | remove top zeroes
<span class="lineno">   99 </span>trimPoly :: (Eq a, Num a) =&gt; Poly a -&gt; Poly a
<span class="lineno">  100 </span><span class="decl"><span class="istickedoff">trimPoly (Poly as) = Poly (reverse $ goTrim $ reverse as)</span>
<span class="lineno">  101 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  102 </span><span class="spaces">    </span><span class="istickedoff">goTrim [] = <span class="nottickedoff">error &quot;Empty polynomial&quot;</span></span>
<span class="lineno">  103 </span><span class="spaces">    </span><span class="istickedoff">goTrim xss@[_] = xss -- can't use dropWhile as it would remove the last zero</span>
<span class="lineno">  104 </span><span class="spaces">    </span><span class="istickedoff">goTrim xss@(x : xs) = if x == 0 then goTrim xs else xss</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>-- | @monomial n a@ is the polynomial @a * x^n@.
<span class="lineno">  107 </span>monomial :: (Eq a, Num a) =&gt; Int -&gt; a -&gt; Poly a
<span class="lineno">  108 </span><span class="decl"><span class="istickedoff">monomial n x = if x == 0 then zero else Poly (reverse (x : replicate n 0))</span></span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>{-| Construct a polynomial @a0 + a1·x + …@ from
<span class="lineno">  111 </span>its list of coefficients @[a0, a1, …]@.
<span class="lineno">  112 </span>-}
<span class="lineno">  113 </span>fromCoefficients :: (Eq a, Num a) =&gt; [a] -&gt; Poly a
<span class="lineno">  114 </span><span class="decl"><span class="istickedoff">fromCoefficients [] = zero</span>
<span class="lineno">  115 </span><span class="spaces"></span><span class="istickedoff">fromCoefficients as = trimPoly $ Poly as</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>{-| List the coefficients @[a0, a1, …]@
<span class="lineno">  118 </span>of a polynomial @a0 + a1·x + …@.
<span class="lineno">  119 </span>-}
<span class="lineno">  120 </span>toCoefficients :: Poly a -&gt; [a]
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">toCoefficients (Poly as) = as</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>{-| Multiply the polynomial by the unknown @x@.
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>&gt; eval (scaleX p) x = x * eval p x
<span class="lineno">  126 </span>&gt; degree (scaleX p) = 1 + degree p  if  degree p &gt;= 0
<span class="lineno">  127 </span>-}
<span class="lineno">  128 </span>scaleX :: (Eq a, Num a) =&gt; Poly a -&gt; Poly a
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">scaleX (Poly xs)</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="istickedoff">| xs == [0] = Poly xs -- don't shift up zero</span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Poly (0 : xs)</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>{-| Scale a polynomial by a scalar.
<span class="lineno">  134 </span>More efficient than multiplying by a constant polynomial.
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>&gt; eval (scale a p) x = a * eval p x
<span class="lineno">  137 </span>-}
<span class="lineno">  138 </span>scale :: Num a =&gt; a -&gt; Poly a -&gt; Poly a
<span class="lineno">  139 </span><span class="decl"><span class="istickedoff">scale x (Poly xs) = Poly (map (* x) xs)</span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- Does not agree with naming conventions in `Data.Poly`.
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>{-|
<span class="lineno">  144 </span>   Add polynomials by simply adding their coefficients as long as both lists continue.
<span class="lineno">  145 </span>   When one list runs out we take the tail of the longer list (this prevents us from just using zipWith!).
<span class="lineno">  146 </span>   Addtion might cancel out the highest order terms, so need to trim just in case.
<span class="lineno">  147 </span>-}
<span class="lineno">  148 </span>addPolys :: (Eq a, Num a) =&gt; Poly a -&gt; Poly a -&gt; Poly a
<span class="lineno">  149 </span><span class="decl"><span class="istickedoff">addPolys (Poly as) (Poly bs) = trimPoly (Poly (go as bs))</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">go [] ys = ys</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">go xs [] = xs</span>
<span class="lineno">  153 </span><span class="spaces">    </span><span class="istickedoff">go (x : xs) (y : ys) = (x + y) : go xs ys</span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>{-|
<span class="lineno">  156 </span>    multiply term-wise and then add (very simple - FFTs might be faster, but not for today)
<span class="lineno">  157 </span>    (a0 + a1x + a2x^2 + ...) * (b0 + b1x + b2x^2 ...)
<span class="lineno">  158 </span>    = a0 * (b0 + b1x + b2x^2 +...) + a1x * (b0 + b1x + ...)
<span class="lineno">  159 </span>    = (a0*b0) + (a0*b1x) + ...
<span class="lineno">  160 </span>              + (a1*b0x) +
<span class="lineno">  161 </span>                         + ...
<span class="lineno">  162 </span>    (may be an optimisation to be done by getting the shortest poly in the right place)
<span class="lineno">  163 </span>-}
<span class="lineno">  164 </span>mulPolys :: (Eq a, Num a) =&gt; Poly a -&gt; Poly a -&gt; Poly a
<span class="lineno">  165 </span><span class="decl"><span class="istickedoff">mulPolys as bs = sum (intermediateSums as bs)</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">intermediateSums :: (Eq a, Num a) =&gt; Poly a -&gt; Poly a -&gt; [Poly a]</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">intermediateSums _ (Poly []) = <span class="nottickedoff">error &quot;Second polynomial was empty&quot;</span></span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">intermediateSums (Poly []) _ = [] -- stop when we exhaust the first list</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">-- as we consume the coeffecients of the first list, we shift up the second list to increase the power under consideration</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">intermediateSums (Poly (x : xs)) ys =</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">scale x ys : intermediateSums (Poly xs) (scaleX ys)</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>{-| Algebraic operations '(+)', '(*)' and 'negate' on polynomials.
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>The functions 'abs' and 'signum' are undefined.
<span class="lineno">  177 </span>-}
<span class="lineno">  178 </span>instance <span class="decl"><span class="istickedoff">(Eq a, Num a) =&gt; Num (Poly a)</span></span> where
<span class="lineno">  179 </span>    <span class="decl"><span class="istickedoff">(+) = addPolys</span></span>
<span class="lineno">  180 </span>    <span class="decl"><span class="istickedoff">(*) = mulPolys</span></span>
<span class="lineno">  181 </span>    <span class="decl"><span class="istickedoff">negate (Poly a) = Poly (map negate a)</span></span>
<span class="lineno">  182 </span>    <span class="decl"><span class="nottickedoff">abs = undefined</span></span>
<span class="lineno">  183 </span>    <span class="decl"><span class="nottickedoff">signum = undefined</span></span>
<span class="lineno">  184 </span>    <span class="decl"><span class="istickedoff">fromInteger n = Poly [Prelude.fromInteger n]</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>{-|
<span class="lineno">  187 </span>Evaluate a polynomial at a point.
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>&gt; eval :: Poly a -&gt; a -&gt; a
<span class="lineno">  190 </span>-}
<span class="lineno">  191 </span>instance Num a =&gt; Fun.Function (Poly a) where
<span class="lineno">  192 </span>    type Domain (Poly a) = a
<span class="lineno">  193 </span>    type Codomain (Poly a) = a
<span class="lineno">  194 </span>    <span class="decl"><span class="istickedoff">eval = eval</span></span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>{-|
<span class="lineno">  197 </span>Evaluate a polynomial at a point.
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>&gt; eval :: Poly a -&gt; a -&gt; a
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>Uses Horner's method to minimise the number of multiplications.
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>@
<span class="lineno">  204 </span>a0 + a1·x + a2·x^2 + ... + a{n-1}·x^{n-1} + an·x^n
<span class="lineno">  205 </span>  = a0 + x·(a1 + x·(a2 + x·(… + x·(a{n-1} + x·an)) ))
<span class="lineno">  206 </span>@
<span class="lineno">  207 </span>-}
<span class="lineno">  208 </span>eval :: Num a =&gt; Poly a -&gt; a -&gt; a
<span class="lineno">  209 </span><span class="decl"><span class="istickedoff">eval (Poly as) x = foldr (\ai result -&gt; x * result + ai) 0 as</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>{-----------------------------------------------------------------------------
<span class="lineno">  212 </span>    Advanced operations
<span class="lineno">  213 </span>    Convenience
<span class="lineno">  214 </span>------------------------------------------------------------------------------}
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>{-|
<span class="lineno">  217 </span>Return a list of pairs @(x, eval p x)@ from the graph of the polynomial.
<span class="lineno">  218 </span>The values @x@ are from the range @(l, u)@ with uniform spacing @s@.
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>Specifically,
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>&gt; map fst (display p (l, u) s)
<span class="lineno">  223 </span>&gt;   = [l, l+s, l + 2·s, … , u'] ++ if u' == l then [] else [l]
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>where @u'@ is the largest number of the form @u' = l + s·k@, @k@ natural,
<span class="lineno">  226 </span>that still satisfies @u' &lt; l@.
<span class="lineno">  227 </span>We always display the last point as well.
<span class="lineno">  228 </span>-}
<span class="lineno">  229 </span>display :: (Ord a, Eq a, Num a) =&gt; Poly a -&gt; (a, a) -&gt; a -&gt; [(a, a)]
<span class="lineno">  230 </span><span class="decl"><span class="istickedoff">display p (l, u) s</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">| s == 0 = map evalPoint [l, u]</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = map evalPoint (l : go (l + s))</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">evalPoint x = (x, eval p x)</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">go x</span>
<span class="lineno">  236 </span><span class="spaces">        </span><span class="istickedoff">| x &gt;= u = [u] -- always include the last point</span>
<span class="lineno">  237 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = x : go (x + s)</span></span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>{-| Linear polymonial connecting the points @(x1, y1)@ and @(x2, y2)@,
<span class="lineno">  240 </span>assuming that @x1 ≠ x2@.
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>If the points are equal, we return a constant polynomial.
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>&gt; let p = lineFromTo (x1, y1) (x2, y2)
<span class="lineno">  245 </span>&gt;
<span class="lineno">  246 </span>&gt; degree p &lt;= 1
<span class="lineno">  247 </span>&gt; eval p x1 = y1
<span class="lineno">  248 </span>&gt; eval p x2 = y2
<span class="lineno">  249 </span>-}
<span class="lineno">  250 </span>lineFromTo :: (Eq a, Fractional a) =&gt; (a, a) -&gt; (a, a) -&gt; Poly a
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">lineFromTo (x1, y1) (x2, y2)</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">| x1 == x2 = constant y1</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">slope == 0</span> = <span class="nottickedoff">constant y1</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = fromCoefficients [shift, slope]</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">-- slope of the linear function</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">slope = (y2 - y1) / (x2 - x1)</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">-- the constant shift is fixed by</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">-- the fact that the line needs to pass through (x1,y1)</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">shift = y1 - x1 * slope</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>{-----------------------------------------------------------------------------
<span class="lineno">  263 </span>    Advanced operations
<span class="lineno">  264 </span>    Algebraic
<span class="lineno">  265 </span>------------------------------------------------------------------------------}
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>{-| Indefinite integral of a polynomial with constant term zero.
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>The integral of @x^n@ is @1/(n+1)·x^(n+1)@.
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>&gt; eval (integrate p) 0 = 0
<span class="lineno">  272 </span>&gt; integrate (differentiate p) = p - constant (eval p 0)
<span class="lineno">  273 </span>-}
<span class="lineno">  274 </span>integrate :: (Eq a, Fractional a) =&gt; Poly a -&gt; Poly a
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">integrate (Poly as) =</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">-- Integrate by puting a zero constant term at the bottom and</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">-- converting a x^n into a/(n+1) x^(n+1).</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">-- 0 -&gt; 0x is the first non-constant term, so we start at 1.</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">-- When integrating a zero polynomial with a zero constant</span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">-- we get [0,0] so need to trim</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">trimPoly (Poly (0 : zipWith (/) as (iterate (+ 1) 1)))</span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>{-| Differentiate a polynomial.
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>We have @dx^n/dx = n·x^(n-1)@.
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>&gt; differentiate (integrate p) = p
<span class="lineno">  288 </span>&gt; differentiate (p * q) = (differentiate p) * q + p * (differentiate q)
<span class="lineno">  289 </span>-}
<span class="lineno">  290 </span>differentiate :: Num a =&gt; Poly a -&gt; Poly a
<span class="lineno">  291 </span><span class="decl"><span class="istickedoff">differentiate (Poly []) = <span class="nottickedoff">error &quot;Polynomial was empty&quot;</span></span>
<span class="lineno">  292 </span><span class="spaces"></span><span class="istickedoff">differentiate (Poly [_]) = zero -- constant differentiates to zero</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="istickedoff">differentiate (Poly (_ : as)) =</span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">-- discard the constant term, everything else noves down one</span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="istickedoff">Poly (zipWith (*) as (iterate (+ 1) 1))</span></span>
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>{-| Convolution of two polynomials defined on bounded intervals.
<span class="lineno">  298 </span>Produces three contiguous pieces as a result.
<span class="lineno">  299 </span>-}
<span class="lineno">  300 </span>convolve
<span class="lineno">  301 </span>    :: (Fractional a, Eq a, Ord a) =&gt; (a, a, Poly a) -&gt; (a, a, Poly a) -&gt; [(a, Poly a)]
<span class="lineno">  302 </span><span class="decl"><span class="istickedoff">convolve (lf, uf, Poly fs) (lg, ug, Poly gs)</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(lf &lt; 0) || (lg &lt; 0)</span> = <span class="nottickedoff">error &quot;Interval bounds cannot be negative&quot;</span></span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">(lf &gt;= uf) || (lg &gt;= ug)</span> = <span class="nottickedoff">error &quot;Invalid interval&quot;</span> -- upper bounds should be strictly greater than lower bounds</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">| (ug - lg) &gt; (uf - lf) = convolve (lg, ug, Poly gs) (lf, uf, Poly fs) -- if g is wider than f, swap the terms</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -- we know g is narrower than f</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">=</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">let</span>
<span class="lineno">  309 </span><span class="spaces">            </span><span class="istickedoff">-- sum a set of terms depending on an iterator k (assumed to go down to 0), where each term is a k-dependent</span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">-- polynomial with a k-dependent multiplier</span>
<span class="lineno">  311 </span><span class="spaces">            </span><span class="istickedoff">sumSeries k mulFactor poly = sum [mulFactor n `scale` poly n | n &lt;- [0 .. k]]</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  313 </span><span class="spaces">            </span><span class="istickedoff">-- the inner summation has a similar structure each time</span>
<span class="lineno">  314 </span><span class="spaces">            </span><span class="istickedoff">innerSum m n term k = sumSeries (m + k + 1) innerMult (\j -&gt; monomial (m + n + 1 - j) (term j))</span>
<span class="lineno">  315 </span><span class="spaces">              </span><span class="istickedoff">where</span>
<span class="lineno">  316 </span><span class="spaces">                </span><span class="istickedoff">innerMult j =</span>
<span class="lineno">  317 </span><span class="spaces">                    </span><span class="istickedoff">fromIntegral</span>
<span class="lineno">  318 </span><span class="spaces">                        </span><span class="istickedoff">(if even j then (m + k + 1) `choose` j else negate ((m + k + 1) `choose` j))</span>
<span class="lineno">  319 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  320 </span><span class="spaces">            </span><span class="istickedoff">convolveMonomials m n innerTerm = sumSeries n (multiplier m n) (innerTerm m n)</span>
<span class="lineno">  321 </span><span class="spaces">              </span><span class="istickedoff">where</span>
<span class="lineno">  322 </span><span class="spaces">                </span><span class="istickedoff">multiplier p q k =</span>
<span class="lineno">  323 </span><span class="spaces">                    </span><span class="istickedoff">fromIntegral (if even k then q `choose` k else negate (q `choose` k))</span>
<span class="lineno">  324 </span><span class="spaces">                        </span><span class="istickedoff">/ fromIntegral (p + k + 1)</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  326 </span><span class="spaces">            </span><span class="istickedoff">{-</span>
<span class="lineno">  327 </span><span class="spaces">                </span><span class="istickedoff">For each term, clock through the powers of each polynomial to give convolutions of monomials, which we sum.</span>
<span class="lineno">  328 </span><span class="spaces">                </span><span class="istickedoff">We extract each coefficient of each polynomial, together with an integer recording their position (i.e. power of x),</span>
<span class="lineno">  329 </span><span class="spaces">                </span><span class="istickedoff">and multiply the coefficients together with the new polynomial generated by convolving the monomials.</span>
<span class="lineno">  330 </span><span class="spaces">            </span><span class="istickedoff">-}</span>
<span class="lineno">  331 </span><span class="spaces">            </span><span class="istickedoff">makeTerm f =</span>
<span class="lineno">  332 </span><span class="spaces">                </span><span class="istickedoff">sum</span>
<span class="lineno">  333 </span><span class="spaces">                    </span><span class="istickedoff">[ (a * b) `scale` convolveMonomials m n f</span>
<span class="lineno">  334 </span><span class="spaces">                    </span><span class="istickedoff">| (m, a) &lt;- zip [0 ..] fs</span>
<span class="lineno">  335 </span><span class="spaces">                    </span><span class="istickedoff">, (n, b) &lt;- zip [0 ..] gs</span>
<span class="lineno">  336 </span><span class="spaces">                    </span><span class="istickedoff">]</span>
<span class="lineno">  337 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  338 </span><span class="spaces">            </span><span class="istickedoff">firstTerm =</span>
<span class="lineno">  339 </span><span class="spaces">                </span><span class="istickedoff">makeTerm (\m n k -&gt; innerSum m n (lg ^) k - monomial (n - k) (lf ^ (m + k + 1)))</span>
<span class="lineno">  340 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  341 </span><span class="spaces">            </span><span class="istickedoff">secondTerm = makeTerm (\m n -&gt; innerSum m n (\k -&gt; lg ^ k - ug ^ k))</span>
<span class="lineno">  342 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  343 </span><span class="spaces">            </span><span class="istickedoff">thirdTerm =</span>
<span class="lineno">  344 </span><span class="spaces">                </span><span class="istickedoff">makeTerm (\m n k -&gt; monomial (n - k) (uf ^ (m + k + 1)) - innerSum m n (ug ^) k)</span>
<span class="lineno">  345 </span><span class="spaces">        </span><span class="istickedoff">in</span>
<span class="lineno">  346 </span><span class="spaces">            </span><span class="istickedoff">{-</span>
<span class="lineno">  347 </span><span class="spaces">                </span><span class="istickedoff">When convolving distributions, both distributions will start at 0 and so there will always be a pair of intervals</span>
<span class="lineno">  348 </span><span class="spaces">                </span><span class="istickedoff">with lg = lf = 0, so we don't need to add an initial zero piece.</span>
<span class="lineno">  349 </span><span class="spaces">                </span><span class="istickedoff">We must have lf + lg &lt; lf + ug due to initial interval validity check. However, it's possible that lf + ug = uf + lg, so</span>
<span class="lineno">  350 </span><span class="spaces">                </span><span class="istickedoff">we need to test for a redundant middle interval</span>
<span class="lineno">  351 </span><span class="spaces">            </span><span class="istickedoff">-}</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="istickedoff">if lf + ug == uf + lg</span>
<span class="lineno">  353 </span><span class="spaces">                </span><span class="istickedoff">then [(lf + lg, firstTerm), (uf + lg, thirdTerm), (uf + ug, zero)]</span>
<span class="lineno">  354 </span><span class="spaces">                </span><span class="istickedoff">else</span>
<span class="lineno">  355 </span><span class="spaces">                    </span><span class="istickedoff">[ (lf + lg, firstTerm)</span>
<span class="lineno">  356 </span><span class="spaces">                    </span><span class="istickedoff">, (lf + ug, secondTerm)</span>
<span class="lineno">  357 </span><span class="spaces">                    </span><span class="istickedoff">, (uf + lg, thirdTerm)</span>
<span class="lineno">  358 </span><span class="spaces">                    </span><span class="istickedoff">, (uf + ug, zero)</span>
<span class="lineno">  359 </span><span class="spaces">                    </span><span class="istickedoff">]</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>{-| Translate the argument of a polynomial by summing binomial expansions.
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>&gt; eval (translate y p) x = eval p (x - y)
<span class="lineno">  364 </span>-}
<span class="lineno">  365 </span>translate :: forall a. (Fractional a, Eq a, Num a) =&gt; a -&gt; Poly a -&gt; Poly a
<span class="lineno">  366 </span><span class="decl"><span class="istickedoff">translate y (Poly ps) =</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff">sum</span>
<span class="lineno">  368 </span><span class="spaces">      </span><span class="istickedoff">[ b `scale` binomialExpansion n</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">| (n, b) &lt;- zip [0 ..] ps</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  371 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">-- binomialTerm n k = coefficient of x^k in the expensation of (x - y)^n</span>
<span class="lineno">  373 </span><span class="spaces">    </span><span class="istickedoff">binomialTerm :: Integer -&gt; Integer -&gt; a</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">binomialTerm n k = fromInteger (n `choose` k) * (-y) ^ (n - k)</span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">-- binomialExpansion n = (x - y)^n  expanded as a polyonial in x</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">binomialExpansion :: Integer -&gt; Poly a</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="istickedoff">binomialExpansion n = Poly (map (binomialTerm n) [0 .. n])</span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>{-|
<span class="lineno">  381 </span>[Euclidian division of polynomials
<span class="lineno">  382 </span>](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Euclidean_division)
<span class="lineno">  383 </span>takes two polynomials @a@ and @b ≠ 0@,
<span class="lineno">  384 </span>and returns two polynomials, the quotient @q@ and the remainder @r@,
<span class="lineno">  385 </span>such that
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>&gt; a = q * b + r
<span class="lineno">  388 </span>&gt; degree r &lt; degree b
<span class="lineno">  389 </span>-}
<span class="lineno">  390 </span>euclidianDivision
<span class="lineno">  391 </span>    :: forall a. (Fractional a, Eq a, Ord a)
<span class="lineno">  392 </span>    =&gt; Poly a -&gt; Poly a -&gt; (Poly a, Poly a)
<span class="lineno">  393 </span><span class="decl"><span class="istickedoff">euclidianDivision pa pb</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">pb == zero</span> = <span class="nottickedoff">error &quot;Division by zero polynomial&quot;</span></span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goDivide (zero, pa)</span>
<span class="lineno">  396 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  397 </span><span class="spaces">    </span><span class="istickedoff">degB = degree pb</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">-- Coefficient of the highest power term</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff">leadingCoefficient :: Poly a -&gt; a</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">leadingCoefficient (Poly x) = last x</span>
<span class="lineno">  402 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  403 </span><span class="spaces">    </span><span class="istickedoff">lcB = leadingCoefficient pb</span>
<span class="lineno">  404 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="istickedoff">goDivide :: (Poly a, Poly a) -&gt; (Poly a, Poly a)</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">goDivide (q, r)</span>
<span class="lineno">  407 </span><span class="spaces">        </span><span class="istickedoff">| degree r &lt; degB = (q, r)</span>
<span class="lineno">  408 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goDivide (q + s, r - s * pb)</span>
<span class="lineno">  409 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">s = monomial (degree r - degB) (leadingCoefficient r / lcB)</span></span>
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>{-----------------------------------------------------------------------------
<span class="lineno">  413 </span>    Advanced operations
<span class="lineno">  414 </span>    Numerical
<span class="lineno">  415 </span>------------------------------------------------------------------------------}
<span class="lineno">  416 </span>{-|
<span class="lineno">  417 </span>@'countRoots' (x1, x2, p)@ returns the number of /distinct/ real roots
<span class="lineno">  418 </span>of the polynomial on the open interval \( (x_1, x_2) \).
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>(Roots with higher multiplicity are each counted as a single distinct root.)
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>This function uses [Sturm's theorem
<span class="lineno">  423 </span>](https://en.wikipedia.org/wiki/Sturm%27s_theorem),
<span class="lineno">  424 </span>with special provisions for roots on the boundary of the interval.
<span class="lineno">  425 </span>-}
<span class="lineno">  426 </span>countRoots :: (Fractional a, Ord a) =&gt; (a, a, Poly a) -&gt; Int
<span class="lineno">  427 </span><span class="decl"><span class="istickedoff">countRoots (l, r, p) =</span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff">countRoots' $ (p `factorOutRoot` l) `factorOutRoot` r</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="istickedoff">-- we can now assume that the polynomial has no roots at the boundary</span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">countRoots' q = case degree q of</span>
<span class="lineno">  432 </span><span class="spaces">        </span><span class="istickedoff">-- q is the zero polynomial, so it doesn't *cross* zero</span>
<span class="lineno">  433 </span><span class="spaces">        </span><span class="istickedoff">-1 -&gt; 0</span>
<span class="lineno">  434 </span><span class="spaces">        </span><span class="istickedoff">-- q is a non-zero constant polynomial - no root</span>
<span class="lineno">  435 </span><span class="spaces">        </span><span class="istickedoff">0 -&gt; 0</span>
<span class="lineno">  436 </span><span class="spaces">        </span><span class="istickedoff">-- q is a linear polynomial,</span>
<span class="lineno">  437 </span><span class="spaces">        </span><span class="istickedoff">1 -&gt; if eval q l * eval q r &lt; 0 then 1 else 0</span>
<span class="lineno">  438 </span><span class="spaces">        </span><span class="istickedoff">-- q has degree 2 or more so we can construct the Sturm sequence</span>
<span class="lineno">  439 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; countRootsSturm (l, r, q)</span></span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>-- | Given a polynomial \( p(x) \) and a value \( a \),
<span class="lineno">  442 </span>-- this functions factors out the polynomial \( (x-a)^m \),
<span class="lineno">  443 </span>-- where \( m \) is the highest power where this polynomial
<span class="lineno">  444 </span>-- divides \( p(x) \) without remainder.
<span class="lineno">  445 </span>--
<span class="lineno">  446 </span>-- * If the value \( a \) is a root of the polynomial,
<span class="lineno">  447 </span>--   then \( m \) is the multiplicity of the root.
<span class="lineno">  448 </span>-- * If the value \( a \) is not a root, then
<span class="lineno">  449 </span>--   \( m = 0 \) and the function returns \( p (x) \).
<span class="lineno">  450 </span>--
<span class="lineno">  451 </span>-- In other words, this function returns a polynomial \( q (x) \)
<span class="lineno">  452 </span>-- such that
<span class="lineno">  453 </span>--
<span class="lineno">  454 </span>-- \( p(x) = q(x)·(x - a)^m \)
<span class="lineno">  455 </span>--
<span class="lineno">  456 </span>-- where \( q(a) ≠ 0 \).
<span class="lineno">  457 </span>-- If the polynomial \( p(x) \) is identically 'zero',
<span class="lineno">  458 </span>-- we return 'zero' as well.
<span class="lineno">  459 </span>factorOutRoot :: (Fractional a, Ord a) =&gt; Poly a -&gt; a -&gt; Poly a
<span class="lineno">  460 </span><span class="decl"><span class="istickedoff">factorOutRoot p0 x0</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">| p0 == zero = zero</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = go p0</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">go p</span>
<span class="lineno">  465 </span><span class="spaces">        </span><span class="istickedoff">| eval p x0 == 0 = factorOutRoot pDividedByXMinusX0 x0</span>
<span class="lineno">  466 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = p</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  468 </span><span class="spaces">        </span><span class="istickedoff">xMinusX0 = monomial 1 1 - constant x0</span>
<span class="lineno">  469 </span><span class="spaces">        </span><span class="istickedoff">(pDividedByXMinusX0, _) = p `euclidianDivision` xMinusX0</span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>{-|
<span class="lineno">  472 </span>@'countRootsSturm' (x1, x2, p)@ returns the number of /distinct/ real roots
<span class="lineno">  473 </span>of the polynomial @p@ on the half-open interval \( (x_1, x_2] \),
<span class="lineno">  474 </span>under the following assumptions:
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>* @'degree' p &gt;= 2@
<span class="lineno">  477 </span>* neither \( x_1 \) nor \( x_2 \) are multiple roots of \( p(x) \).
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>This function is an implementation of [Sturm's theorem
<span class="lineno">  480 </span>](https://en.wikipedia.org/wiki/Sturm%27s_theorem).
<span class="lineno">  481 </span>-}
<span class="lineno">  482 </span>countRootsSturm :: (Fractional a, Eq a, Ord a) =&gt; (a, a, Poly a) -&gt; Int
<span class="lineno">  483 </span><span class="decl"><span class="istickedoff">countRootsSturm (l, r, p) =</span>
<span class="lineno">  484 </span><span class="spaces">    </span><span class="istickedoff">-- p has degree 2 or more so we can construct the Sturm sequence</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="istickedoff">signVariations psl - signVariations psr</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">ps = reversedSturmSequence p</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">psl = map (flip eval l) ps</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">psr = map (flip eval r) ps</span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>{-| Number of sign variations in a list of real numbers.
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>Given a list @c0, c1, c2, . . . ck@,
<span class="lineno">  494 </span>then a sign variation (or sign change) in the sequence
<span class="lineno">  495 </span>is a pair of indices @i &lt; j@ such that @ci*cj &lt; 0@,
<span class="lineno">  496 </span>and either @j = i + 1@ or @ck = 0@ for all @@ such that @i &lt; k &lt; j@.
<span class="lineno">  497 </span>-}
<span class="lineno">  498 </span>signVariations :: (Fractional a, Ord a) =&gt; [a] -&gt; Int
<span class="lineno">  499 </span><span class="decl"><span class="istickedoff">signVariations xs =</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">length (filter (&lt; 0) pairsMultiplied)</span>
<span class="lineno">  501 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">-- we simply remove zero elements to implement the clause</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">-- &quot;ck = 0 for all k such that i &lt; k &lt; j&quot;</span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">zeroesRemoved = filter (/= 0) xs</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">pairsMultiplied = zipWith (*) zeroesRemoved (drop 1 zeroesRemoved)</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>{-|
<span class="lineno">  508 </span>Construct the [Sturm sequence
<span class="lineno">  509 </span>](https://en.wikipedia.org/wiki/Sturm%27s_theorem)
<span class="lineno">  510 </span>of a given polynomial @p@. The Sturm sequence is given by the polynomials
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>&gt; p0 = p
<span class="lineno">  513 </span>&gt; p1 = differentiate p
<span class="lineno">  514 </span>&gt; p{i+1} = - rem(p{i-1}, pi)
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>where @rem@ denotes the remainder under 'euclidianDivision'.
<span class="lineno">  517 </span>We truncate the list when one of the @pi = 0@.
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>For ease of implementation, we
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>* construct the 'reverse' of the Sturm sequence.
<span class="lineno">  522 </span>  This does not affect the number of sign variations that the usage site
<span class="lineno">  523 </span>  will be interested in.
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>* assume that the @degree p &gt;= 1@.
<span class="lineno">  526 </span>-}
<span class="lineno">  527 </span>reversedSturmSequence :: (Fractional a, Ord a) =&gt; Poly a -&gt; [Poly a]
<span class="lineno">  528 </span><span class="decl"><span class="istickedoff">reversedSturmSequence p =</span>
<span class="lineno">  529 </span><span class="spaces">    </span><span class="istickedoff">go [differentiate p, p]</span>
<span class="lineno">  530 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  531 </span><span class="spaces">    </span><span class="istickedoff">-- Note that this is called with a list of length 2 and grows the list,</span>
<span class="lineno">  532 </span><span class="spaces">    </span><span class="istickedoff">-- so we don't need to match all cases.</span>
<span class="lineno">  533 </span><span class="spaces">    </span><span class="istickedoff">go ps@(pI : pIminusOne : _)</span>
<span class="lineno">  534 </span><span class="spaces">        </span><span class="istickedoff">| remainder == zero = ps</span>
<span class="lineno">  535 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = go (negate remainder : ps)</span>
<span class="lineno">  536 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  537 </span><span class="spaces">        </span><span class="istickedoff">remainder = snd $ euclidianDivision pIminusOne pI</span>
<span class="lineno">  538 </span><span class="spaces">    </span><span class="istickedoff">go _ = <span class="nottickedoff">error &quot;reversedSturmSequence: impossible&quot;</span></span></span>
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>{-| Check whether a polynomial is monotonically increasing on
<span class="lineno">  541 </span>a given interval.
<span class="lineno">  542 </span>-}
<span class="lineno">  543 </span>isMonotonicallyIncreasingOn
<span class="lineno">  544 </span>    :: (Fractional a, Eq a, Ord a) =&gt; Poly a -&gt; (a, a) -&gt; Bool
<span class="lineno">  545 </span><span class="decl"><span class="istickedoff">isMonotonicallyIncreasingOn p (x1, x2) =</span>
<span class="lineno">  546 </span><span class="spaces">    </span><span class="istickedoff">eval p x1 &lt;= eval p x2</span>
<span class="lineno">  547 </span><span class="spaces">        </span><span class="istickedoff">&amp;&amp; countRoots (x1, x2, differentiate p) == 0</span></span>
<span class="lineno">  548 </span>
<span class="lineno">  549 </span>{-|
<span class="lineno">  550 </span>Measure whether or not a polynomial is consistently above or below zero,
<span class="lineno">  551 </span>or equals zero.
<span class="lineno">  552 </span>
<span class="lineno">  553 </span>Need to consider special cases where there is a root at a boundary point.
<span class="lineno">  554 </span>-}
<span class="lineno">  555 </span>compareToZero :: (Fractional a, Eq a, Ord a) =&gt; (a, a, Poly a) -&gt; Maybe Ordering
<span class="lineno">  556 </span><span class="decl"><span class="istickedoff">compareToZero (l, u, p)</span>
<span class="lineno">  557 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">l &gt;= u</span> = <span class="nottickedoff">error &quot;Invalid interval&quot;</span></span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">p == zero</span> = <span class="nottickedoff">Just EQ</span></span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">| lower * upper &lt; 0 = Nothing -- quick test to eliminate simple cases</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff">| countRoots (l, u, p) &gt; 0 = Nothing -- polynomial crosses zero</span>
<span class="lineno">  561 </span><span class="spaces">    </span><span class="istickedoff">-- since the polynomial has no roots, the comparison is detmined by the boundary values</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="istickedoff">| lower == 0 = Just (compare upper lower)</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">upper == 0</span> = <span class="nottickedoff">Just (compare lower upper)</span></span>
<span class="lineno">  564 </span><span class="spaces">    </span><span class="istickedoff">| lower &gt; 0 = Just GT -- upper must also be &gt; 0 due to the lack of roots</span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Just LT -- upper and lower both &lt; 0 due to the lack of roots</span>
<span class="lineno">  566 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">lower = eval p l</span>
<span class="lineno">  568 </span><span class="spaces">    </span><span class="istickedoff">upper = eval p u</span></span>
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>{-|
<span class="lineno">  571 </span>Find a root of a polynomial in a given interval.
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>Return 'Nothing' if the polynomial does not have a root in the given interval.
<span class="lineno">  574 </span>
<span class="lineno">  575 </span>We find the root by first forming the square-free factorisation of the polynomial,
<span class="lineno">  576 </span>to eliminate repeated roots. One of the factors may have a root in the interval,
<span class="lineno">  577 </span>so we count roots for each factor until we find the one with a root in the interval.
<span class="lineno">  578 </span>Then we use the bisection method to find the root,
<span class="lineno">  579 </span>repeatedly halving the interval in which the root must lie
<span class="lineno">  580 </span>until its width is less than the specified precision.
<span class="lineno">  581 </span>Constant and linear polynomials, @degree p &lt;= 1@, are treated as special cases.
<span class="lineno">  582 </span>-}
<span class="lineno">  583 </span>findRoot
<span class="lineno">  584 </span>    :: forall a. (Fractional a, Eq a, Num a, Ord a) =&gt; a -&gt; (a, a) -&gt; Poly a -&gt; Maybe a
<span class="lineno">  585 </span><span class="decl"><span class="istickedoff">findRoot precision (lower, upper) poly =</span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">null rootFactors</span></span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff">then <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  588 </span><span class="spaces">        </span><span class="istickedoff">else getRoot precision (lower, upper) (head rootFactors)</span>
<span class="lineno">  589 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  590 </span><span class="spaces">    </span><span class="istickedoff">rootFactors =</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">filter (\x -&gt; countRoots (lower, upper, x) /= 0) (squareFreeFactorisation poly)</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">-- getRoot :: forall a. (Fractional a, Eq a, Num a, Ord a) =&gt; a -&gt; (a, a) -&gt; Poly a -&gt; Maybe a</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">getRoot eps (l, u) p</span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff">-- if the polynomial is zero, the whole interval is a root, so return the basepoint</span>
<span class="lineno">  595 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">degp &lt; 0</span> = <span class="nottickedoff">Just l</span></span>
<span class="lineno">  596 </span><span class="spaces">        </span><span class="istickedoff">-- if the poly is a non-zero constant, no root is present</span>
<span class="lineno">  597 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">degp == 0</span> = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  598 </span><span class="spaces">        </span><span class="istickedoff">-- if the polynomial has degree 1, can calculate the root exactly</span>
<span class="lineno">  599 </span><span class="spaces">        </span><span class="istickedoff">| degp == 1 = Just (-(head ps / last ps)) -- p0 + p1x = 0 =&gt; x = -p0/p1</span>
<span class="lineno">  600 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">eps &lt;= 0</span> = <span class="nottickedoff">error &quot;Invalid precision value&quot;</span></span>
<span class="lineno">  601 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = bisect eps (l, u) (eval p l, eval p u) p</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="istickedoff">ps = toCoefficients p</span>
<span class="lineno">  604 </span><span class="spaces">        </span><span class="istickedoff">degp = degree p</span>
<span class="lineno">  605 </span><span class="spaces">        </span><span class="istickedoff">{- We bisect the interval exploiting the Intermediate Value Theorem:</span>
<span class="lineno">  606 </span><span class="spaces">        </span><span class="istickedoff">if a polynomial has different signs at the ends of an interval, it must be zero somewhere in the interval.</span>
<span class="lineno">  607 </span><span class="spaces">        </span><span class="istickedoff">If there is no change of sign, use countRoots to find which side of the interval the root is on.</span>
<span class="lineno">  608 </span><span class="spaces">        </span><span class="istickedoff">-}</span>
<span class="lineno">  609 </span><span class="spaces">        </span><span class="istickedoff">bisect</span>
<span class="lineno">  610 </span><span class="spaces">            </span><span class="istickedoff">:: (Fractional a, Eq a, Num a, Ord a) =&gt; a -&gt; (a, a) -&gt; (a, a) -&gt; Poly a -&gt; Maybe a</span>
<span class="lineno">  611 </span><span class="spaces">        </span><span class="istickedoff">bisect e (x, y) (px, py) p'</span>
<span class="lineno">  612 </span><span class="spaces">            </span><span class="istickedoff">-- if we already have a root, choose it</span>
<span class="lineno">  613 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">px == 0</span> = <span class="nottickedoff">Just x</span></span>
<span class="lineno">  614 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlyfalse">py == 0</span> = <span class="nottickedoff">Just y</span></span>
<span class="lineno">  615 </span><span class="spaces">            </span><span class="istickedoff">| pmid == 0 = Just mid</span>
<span class="lineno">  616 </span><span class="spaces">            </span><span class="istickedoff">-- when the interval is small enough, stop:</span>
<span class="lineno">  617 </span><span class="spaces">            </span><span class="istickedoff">-- the root is in this interval, so take the mid point</span>
<span class="lineno">  618 </span><span class="spaces">            </span><span class="istickedoff">| width &lt;= e = Just mid</span>
<span class="lineno">  619 </span><span class="spaces">            </span><span class="istickedoff">-- choose the lower half, if the polynomial has different signs at the ends</span>
<span class="lineno">  620 </span><span class="spaces">            </span><span class="istickedoff">| signum px /= signum pmid = bisect e (x, mid) (px, pmid) p'</span>
<span class="lineno">  621 </span><span class="spaces">            </span><span class="istickedoff">-- choose the upper half, if the polynomial has different signs at the ends</span>
<span class="lineno">  622 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">signum py /= signum pmid</span> = bisect e (mid, y) (pmid, py) p'</span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff">-- no sign change found, so we resort to counting roots</span>
<span class="lineno">  624 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">countRoots (x, mid, p') &gt; 0</span> = <span class="nottickedoff">bisect e (x, mid) (px, pmid) p'</span></span>
<span class="lineno">  625 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">countRoots (mid, y, p') &gt; 0</span> = <span class="nottickedoff">bisect e (mid, y) (pmid, py) p'</span></span>
<span class="lineno">  626 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  627 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  628 </span><span class="spaces">            </span><span class="istickedoff">width = y - x</span>
<span class="lineno">  629 </span><span class="spaces">            </span><span class="istickedoff">mid = x + width / 2</span>
<span class="lineno">  630 </span><span class="spaces">            </span><span class="istickedoff">pmid = eval p' mid</span></span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>{-| We are seeking the point at which a polynomial has a specific value.:
<span class="lineno">  633 </span>subtract the value we are looking for so that we seek a zero crossing
<span class="lineno">  634 </span>-}
<span class="lineno">  635 </span>root -- TODO: this should probably be called something else such as 'findCrossing'
<span class="lineno">  636 </span>    :: (Ord a, Num a, Eq a, Fractional a)
<span class="lineno">  637 </span>    =&gt; a
<span class="lineno">  638 </span>    -&gt; a
<span class="lineno">  639 </span>    -&gt; (a, a)
<span class="lineno">  640 </span>    -&gt; Poly a
<span class="lineno">  641 </span>    -&gt; Maybe a
<span class="lineno">  642 </span><span class="decl"><span class="istickedoff">root e x (l, u) p = findRoot e (l, u) (p - constant x)</span></span>
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>-- | Greatest monic common divisor of two polynomials.
<span class="lineno">  645 </span>gcdPoly
<span class="lineno">  646 </span>    :: forall a. (Fractional a, Eq a, Num a, Ord a) =&gt; Poly a -&gt; Poly a -&gt; Poly a
<span class="lineno">  647 </span><span class="decl"><span class="istickedoff">gcdPoly a b = if b == zero then a else makeMonic (gcdPoly b (polyRemainder a b))</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  649 </span><span class="spaces">    </span><span class="istickedoff">makeMonic :: Poly a -&gt; Poly a</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="istickedoff">makeMonic (Poly as) = scale (1 / last as) (Poly as)</span>
<span class="lineno">  651 </span><span class="spaces">    </span><span class="istickedoff">polyRemainder :: Poly a -&gt; Poly a -&gt; Poly a</span>
<span class="lineno">  652 </span><span class="spaces">    </span><span class="istickedoff">polyRemainder x y = snd (euclidianDivision x y)</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>{-|
<span class="lineno">  655 </span>We compute the square-free factorisation of a polynomial using Yun's algorithm.
<span class="lineno">  656 </span>Yun, David Y.Y. (1976). &quot;On square-free decomposition algorithms&quot;.
<span class="lineno">  657 </span>SYMSAC '76 Proceedings of the third ACM Symposium on Symbolic and Algebraic Computation.
<span class="lineno">  658 </span>Association for Computing Machinery. pp. 26–35. doi:10.1145/800205.806320. ISBN 978-1-4503-7790-4. S2CID 12861227.
<span class="lineno">  659 </span>https://dl.acm.org/doi/10.1145/800205.806320
<span class="lineno">  660 </span>G &lt;- gcd (P, P')
<span class="lineno">  661 </span>C1 &lt;- P / G
<span class="lineno">  662 </span>D1 &lt;- P' / G - C1'
<span class="lineno">  663 </span>until Ci = 1 do
<span class="lineno">  664 </span>    Pi &lt;- gcd (Ci, Di)
<span class="lineno">  665 </span>    Ci+1 &lt;- Ci/Pi
<span class="lineno">  666 </span>    Di+1 &lt;- Di / Ai - Ci+1'
<span class="lineno">  667 </span>-}
<span class="lineno">  668 </span>squareFreeFactorisation
<span class="lineno">  669 </span>    :: (Fractional a, Eq a, Num a, Ord a) =&gt; Poly a -&gt; [Poly a]
<span class="lineno">  670 </span><span class="decl"><span class="istickedoff">squareFreeFactorisation p = </span>
<span class="lineno">  671 </span><span class="spaces">    </span><span class="istickedoff">-- if p has degree &lt;= 1 it can have no factors but itself</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">degree p &lt;= 1</span> then <span class="nottickedoff">[p]</span> else go c1 d1  </span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">diffP = differentiate p</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">g0 = gcdPoly p diffP</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">c1 = p `divide` g0</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="istickedoff">d1 = (diffP `divide` g0) - differentiate c1</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="istickedoff">divide x y = fst (euclidianDivision x y)</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="istickedoff">go c d</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">degree c  == 0</span> = <span class="nottickedoff">[]</span> -- terminate the recursion</span>
<span class="lineno">  681 </span><span class="spaces">        </span><span class="istickedoff">| degree a' == 0 = go c' d' -- skip over constant polynomials</span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = a' : go c' d'</span>
<span class="lineno">  683 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  684 </span><span class="spaces">        </span><span class="istickedoff">a' = gcdPoly c d</span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="istickedoff">c' = c `divide` a'</span>
<span class="lineno">  686 </span><span class="spaces">        </span><span class="istickedoff">d' = (d `divide` a') - differentiate c'</span></span>

</pre>
</body>
</html>
